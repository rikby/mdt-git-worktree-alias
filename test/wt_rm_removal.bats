#!/usr/bin/env bats
#
# Tests for: WTA - Worktree Removal (git wt-rm)
# Feature: Safe removal of worktrees with path discovery
# Requirements: Derived from git_config_alias_worktree.sh
# Generated by: /mdt:tests
# Status: RED (implementation pending)
#

setup() {
    load 'test_helper/common-setup.bash'
    _common_setup

    # Create a shared test repo for all tests in this file
    TEST_REPO_DIR=$(mktemp -d)
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1
}

teardown() {
    if [[ -n "$TEST_REPO_DIR" && -d "$TEST_REPO_DIR" ]]; then
        cleanup_test_repo "$TEST_REPO_DIR"
    fi
    _common_teardown
}

# Feature: wt-rm Ticket Validation

@test "wt-rm: validates 3-digit ticket number" {
    # Given: git wt-rm command
    # When: executed with non-numeric input
    # Then: should exit with code 3 and show error

    # Test validation regex logic
    worktree="abc"

    if [[ ! "$worktree" =~ [0-9][0-9][0-9] ]]; then
        has_validation_error=true
    else
        has_validation_error=false
    fi

    assert "$has_validation_error"
}

@test "wt-rm: extracts ticket number from input" {
    # Given: various input formats
    # When: extracting ticket number
    # Then: should correctly extract 3 digits

    # Test plain number
    worktree="123"
    ticket_number=$(echo "$worktree" | grep -Eo "[0-9][0-9][0-9]")
    assert_equal "$ticket_number" "123"

    # Test prefixed format
    worktree="WTA-456"
    ticket_number=$(echo "$worktree" | grep -Eo "[0-9][0-9][0-9]")
    assert_equal "$ticket_number" "456"
}

# Feature: wt-rm Path Resolution

@test "wt-rm: uses same path resolution as git wt" {
    # Given: worktree.defaultPath configuration
    # When: resolving worktree path for removal
    # Then: should use same logic as git wt

    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    # Simulate the path resolution logic (same as git wt)
    default_path=".gitWT/{worktree_name}"
    worktree="WTA-123"
    project_dir="$(basename "$(git_test rev-parse --show-toplevel)")"

    # Replace {project_dir} first
    if [[ "$default_path" == *"{project_dir}"* ]]; then
        default_path_with_project=$(echo "$default_path" | sed "s/{project_dir}/$project_dir/g")
    else
        default_path_with_project="$default_path"
    fi

    # Replace {worktree_name}
    if [[ "$default_path_with_project" == *"{worktree_name}"* ]]; then
        worktree_path=$(echo "$default_path_with_project" | sed "s/{worktree_name}/$worktree/g")
    else
        default_path_with_project="${default_path_with_project%/}"
        worktree_path="$default_path_with_project/$worktree"
    fi

    # Expand ~
    worktree_path="${worktree_path/#\~/$HOME}"

    # Convert relative to absolute
    if [[ "$worktree_path" == /* ]]; then
        :
    else
        repo_root="$(git_test rev-parse --show-toplevel)"
        worktree_path="$repo_root/$worktree_path"
    fi

    # Compare paths relative to repo root to avoid symlink issues
    repo_root="$(git_test rev-parse --show-toplevel)"
    expected_relative=".gitWT/WTA-123"

    # Get relative path from worktree_path to repo_root
    actual_relative="${worktree_path#$repo_root/}"
    actual_relative="${actual_relative#/}"  # Remove leading slash

    assert_equal "$actual_relative" "$expected_relative"
}

@test "wt-rm: handles absolute paths" {
    # Given: absolute worktree.defaultPath
    # When: resolving path for removal
    # Then: should not prepend repo root

    git_test config worktree.defaultPath "$HOME/worktrees/{worktree_name}"

    default_path="$HOME/worktrees/{worktree_name}"
    worktree="WTA-123"

    default_path_with_project="$default_path"
    worktree_path=$(echo "$default_path_with_project" | sed "s/{worktree_name}/$worktree/g")
    worktree_path="${worktree_path/#\~/$HOME}"

    if [[ "$worktree_path" == /* ]]; then
        # Absolute path, use as-is
        :
    else
        repo_root="$(git_test rev-parse --show-toplevel)"
        worktree_path="$repo_root/$worktree_path"
    fi

    assert_regex "$worktree_path" "^$HOME"
}

# Feature: wt-rm Error Handling

@test "wt-rm: errors when worktree not found" {
    # Given: no existing worktree at resolved path
    # When: attempting removal
    # Then: should exit with error code 1

    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    default_path=".gitWT/{worktree_name}"
    worktree="WTA-999"

    # Resolve path
    default_path_with_project="$default_path"
    worktree_path=$(echo "$default_path_with_project" | sed "s/{worktree_name}/$worktree/g")
    repo_root="$(git_test rev-parse --show-toplevel)"
    worktree_path="$repo_root/$worktree_path"

    # Check if exists
    if [ ! -d "$worktree_path" ]; then
        has_error=true
        exit_code=1
    fi

    assert "$has_error"
    assert_equal "$exit_code" 1
}

@test "wt-rm: lists existing worktrees on error" {
    # Given: worktree not found
    # When: showing error message
    # Then: should include 'git worktree list' output

    # Simulate error message
    worktree_path="$TEST_REPO_DIR/.gitWT/WTA-999"
    error_message="error: Worktree not found at $worktree_path"
    listing_instruction="Listing existing worktrees:"

    assert_regex "$error_message" "Worktree not found"
    assert_regex "$listing_instruction" "existing worktrees"
}

@test "wt-rm: uses default path when config missing" {
    # Given: no worktree.defaultPath configured
    # When: resolving path
    # Then: should use fallback .gitWT/{worktree_name}

    # Clear config
    git_test config --unset worktree.defaultPath 2>/dev/null || true

    # Check both local and global config separately
    if default_path=$(git_test config worktree.defaultPath 2>/dev/null); then
        # Found local config
        :
    elif default_path=$(git_test config --global worktree.defaultPath 2>/dev/null); then
        # Found global config
        :
    else
        # No config found, use default
        default_path=".gitWT/{worktree_name}"
    fi

    assert_equal "$default_path" ".gitWT/{worktree_name}"
}
