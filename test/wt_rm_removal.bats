#!/usr/bin/env bats
#
# Tests for: WTA - Worktree Removal (git wt-rm)
# Feature: Safe removal of worktrees with path discovery
# Requirements: Derived from git_config_alias_worktree.sh
# Generated by: /mdt:tests
# Status: GREEN (calls actual git wt-rm alias)
#
# WTA-004: Tests for unmerged branch safety behavior
#

setup() {
    load 'test_helper/common-setup.bash'
    _common_setup

    # Create a shared test repo for all tests in this file
    TEST_REPO_DIR=$(mktemp -d)
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1
}

teardown() {
    if [[ -n "$TEST_REPO_DIR" && -d "$TEST_REPO_DIR" ]]; then
        cleanup_test_repo "$TEST_REPO_DIR"
    fi
    _common_teardown
}

# Feature: wt-rm Ticket Validation

@test "wt-rm: handles text input" {
    # Given: git wt-rm command
    # When: executed with text input (feature branch)
    # Then: should handle as worktree name and remove it

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.wt.defaultPath ".gitWT/{worktree_name}"

    # Create a feature branch worktree
    run git_test wt feature-auth 2>&1 || true
    git_test show-ref --verify --quiet "refs/heads/feature-auth"

    # Call actual git wt-rm command with text input
    run git_test wt-rm feature-auth <<< "y" 2>&1 || true

    # Should successfully remove the worktree
    assert_success
    assert_output --partial "Removed worktree"

    # Verify worktree was actually removed
    [ ! -d "$TEST_REPO_DIR/.gitWT/feature-auth" ]
}

@test "wt-rm: extracts ticket number from input" {
    # Given: various input formats
    # When: extracting ticket number
    # Then: should correctly extract 3 digits

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    # Create a worktree first with plain number
    run git_test wt 123 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-123" ]

    # Test removal with plain number
    WT_TEST_RESPONSE="y" run git_test wt-rm 123 2>&1 || true
    assert_output --partial "WTA-123"

    # Create another worktree with prefixed format
    run git_test wt 456 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-456" ]

    # Test removal with prefixed format
    WT_TEST_RESPONSE="y" run git_test wt-rm WTA-456 2>&1 || true
    assert_output --partial "WTA-456"
}

# Feature: wt-rm Path Resolution

@test "wt-rm: uses same path resolution as git wt" {
    # Given: worktree.defaultPath configuration
    # When: resolving worktree path for removal
    # Then: should use same logic as git wt

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    # Create worktree first
    run git_test wt 123 2>&1 || true

    # Remove worktree with WT_TEST_RESPONSE for automated confirmation
    WT_TEST_RESPONSE="y" run git_test wt-rm 123 2>&1 || true

    # Verify it found and removed the correct path
    assert_output --partial ".gitWT/WTA-123"
    assert_output --partial "Removed worktree"
}

@test "wt-rm: handles absolute paths" {
    # Given: absolute worktree.defaultPath
    # When: resolving path for removal
    # Then: should find worktree at absolute path

    TEST_WORKTREE_BASE=$(mktemp -d)
    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath "$TEST_WORKTREE_BASE/{worktree_name}"

    # Create worktree at absolute path
    run git_test wt 789 2>&1 || true
    [ -d "$TEST_WORKTREE_BASE/WTA-789" ]

    # Remove worktree with WT_TEST_RESPONSE for automated confirmation
    WT_TEST_RESPONSE="y" run git_test wt-rm 789 2>&1 || true

    # Verify it found and removed the correct absolute path
    assert_output --partial "$TEST_WORKTREE_BASE/WTA-789"
    assert_output --partial "Removed worktree"

    # Cleanup the worktree base directory
    rmdir "$TEST_WORKTREE_BASE" 2>/dev/null || true
}

# Feature: wt-rm Error Handling

@test "wt-rm: errors when worktree not found" {
    # Given: no existing worktree at resolved path
    # When: attempting removal
    # Then: should exit with error code 1

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    # Try to remove non-existent worktree
    WT_TEST_RESPONSE="y" run git_test wt-rm 999 2>&1 || true

    assert_failure
    assert_output --partial "Worktree not found"
}

@test "wt-rm: lists existing worktrees on error" {
    # Given: worktree not found
    # When: showing error message
    # Then: should include 'git worktree list' output

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    # Create a worktree first so there's something to list
    run git_test wt 111 2>&1 || true

    # Try to remove non-existent worktree (should list existing ones)
    WT_TEST_RESPONSE="y" run git_test wt-rm 999 2>&1 || true

    assert_output --partial "Worktree not found"
    assert_output --partial "existing worktrees"

    # Cleanup the created worktree
    if [ -d "$TEST_REPO_DIR/.gitWT/WTA-111" ]; then
        git_test worktree remove "$TEST_REPO_DIR/.gitWT/WTA-111" 2>/dev/null || true
    fi
}

@test "wt-rm: uses default path when config missing" {
    # Given: no worktree.defaultPath configured
    # When: removing worktree
    # Then: wt-rm should use default .gitWT/{worktree_name} (non-interactive)

    create_mdt_config "$TEST_REPO_DIR" "WTA"

    # First, create a worktree with a known path
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"
    run git_test wt 222 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-222" ]

    # Clear config to test wt-rm's fallback behavior
    git_test config --unset worktree.defaultPath 2>/dev/null || true
    git_test config --global --unset worktree.defaultPath 2>/dev/null || true

    # Remove worktree - wt-rm should use default path non-interactively
    WT_TEST_RESPONSE="y" run git_test wt-rm 222 2>&1 || true

    # Should show warning about missing config
    assert_output --partial "worktree.wt.defaultPath is not configured"
    assert_output --partial "Using default path"

    # Should still find and remove the worktree
    assert_output --partial "WTA-222"
    assert_output --partial "Removed worktree"

    # Verify worktree was actually removed
    [ ! -d "$TEST_REPO_DIR/.gitWT/WTA-222" ]
}

@test "wt-rm: cancels removal when response is no" {
    # Given: an existing worktree
    # When: user responds 'n' to confirmation prompt
    # Then: should cancel removal

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    # Create worktree
    run git_test wt 333 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-333" ]

    # Try to remove with 'n' response
    WT_TEST_RESPONSE="n" run git_test wt-rm 333 2>&1 || true

    assert_output --partial "Cancelled"

    # Verify worktree still exists
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-333" ]

    # Cleanup
    git_test worktree remove "$TEST_REPO_DIR/.gitWT/WTA-333" 2>/dev/null || true
}

# Feature: wt-rm Unmerged Branch Safety (WTA-004)

@test "wt-rm: preserves branch with unmerged commits" {
    # Given: a worktree with unmerged commits
    # When: attempting to remove worktree and delete branch
    # Then: should preserve branch and show Git error

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.wt.defaultPath ".gitWT/{worktree_name}"

    # Create worktree
    run git_test wt 404 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-404" ]

    # Add unmerged commit to the branch
    cd "$TEST_REPO_DIR/.gitWT/WTA-404" || return 1
    echo "unmerged work" > unmerged.txt
    git_test add unmerged.txt
    git_test commit -m "Unmerged commit"
    cd "$TEST_REPO_DIR" || return 1

    # Attempt to remove with branch deletion
    # WT_TEST_RESPONSE provides: "y" for worktree removal, "y" for branch deletion
    WT_TEST_RESPONSE="y
y" run git_test wt-rm 404 2>&1 || true

    # Worktree should be removed
    assert_output --partial "Removed worktree"
    [ ! -d "$TEST_REPO_DIR/.gitWT/WTA-404" ]

    # Branch should be preserved due to unmerged commits
    # Git will show error about branch not being fully merged
    assert_output --partial "not fully merged"

    # Verify branch still exists
    git_test show-ref --verify --quiet "refs/heads/WTA-404"

    # Cleanup: force delete the branch for test teardown
    git_test branch -D WTA-404 2>/dev/null || true
}

@test "wt-rm: deletes branch when fully merged" {
    # Given: a worktree with merged commits
    # When: attempting to remove worktree and delete branch
    # Then: should successfully delete branch

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.wt.defaultPath ".gitWT/{worktree_name}"

    # Create worktree
    run git_test wt 405 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-405" ]

    # Add commit and merge it to main
    cd "$TEST_REPO_DIR/.gitWT/WTA-405" || return 1
    echo "merged work" > merged.txt
    git_test add merged.txt
    git_test commit -m "Merged commit"
    cd "$TEST_REPO_DIR" || return 1

    # Merge branch to main (making it fully merged)
    git_test merge WTA-405 --no-edit

    # Attempt to remove with branch deletion
    WT_TEST_RESPONSE="y
y" run git_test wt-rm 405 2>&1 || true

    # Worktree should be removed
    assert_output --partial "Removed worktree"
    [ ! -d "$TEST_REPO_DIR/.gitWT/WTA-405" ]

    # Branch should be deleted since it's fully merged
    assert_output --partial "Deleted branch: WTA-405"

    # Verify branch no longer exists
    run git_test show-ref --verify --quiet "refs/heads/WTA-405" 2>&1 || true
    assert_failure
}

@test "wt-rm: handles never-merged branch" {
    # Given: a branch that was never merged to any other branch
    # When: attempting to remove worktree and delete branch
    # Then: should preserve branch (Git treats unmerged as safety check)

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.wt.defaultPath ".gitWT/{worktree_name}"

    # Create worktree
    run git_test wt 406 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-406" ]

    # Add commits but never merge
    cd "$TEST_REPO_DIR/.gitWT/WTA-406" || return 1
    echo "isolated work" > isolated.txt
    git_test add isolated.txt
    git_test commit -m "Isolated commit"
    cd "$TEST_REPO_DIR" || return 1

    # Attempt to remove with branch deletion
    WT_TEST_RESPONSE="y
y" run git_test wt-rm 406 2>&1 || true

    # Worktree should be removed
    assert_output --partial "Removed worktree"
    [ ! -d "$TEST_REPO_DIR/.gitWT/WTA-406" ]

    # Branch should be preserved (never merged = unmerged in Git's eyes)
    assert_output --partial "not fully merged"

    # Verify branch still exists
    git_test show-ref --verify --quiet "refs/heads/WTA-406"

    # Cleanup
    git_test branch -D WTA-406 2>/dev/null || true
}

@test "wt-rm: allows declining branch deletion after failed attempt" {
    # Given: a worktree with unmerged commits
    # When: user declines branch deletion after Git error
    # Then: should keep worktree removed and branch preserved

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.wt.defaultPath ".gitWT/{worktree_name}"

    # Create worktree
    run git_test wt 407 2>&1 || true
    [ -d "$TEST_REPO_DIR/.gitWT/WTA-407" ]

    # Add unmerged commit
    cd "$TEST_REPO_DIR/.gitWT/WTA-407" || return 1
    echo "keep me" > keep.txt
    git_test add keep.txt
    git_test commit -m "Commit to keep"
    cd "$TEST_REPO_DIR" || return 1

    # Note: This test verifies the behavior where Git itself rejects
    # the branch deletion (due to -d flag), so the user doesn't get
    # a second chance to decline - Git rejects it automatically
    WT_TEST_RESPONSE="y" run git_test wt-rm 407 2>&1 || true

    # Worktree should be removed
    assert_output --partial "Removed worktree"
    [ ! -d "$TEST_REPO_DIR/.gitWT/WTA-407" ]

    # Branch should be preserved by Git's safety check
    git_test show-ref --verify --quiet "refs/heads/WTA-407"

    # Cleanup
    git_test branch -D WTA-407 2>/dev/null || true
}
