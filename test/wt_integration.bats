#!/usr/bin/env bats
#
# Tests for: WTA - Integration Scenarios
# Feature: End-to-end workflow testing
# Requirements: Derived from git_config_alias_worktree.sh
# Generated by: /mdt:tests
# Status: RED (implementation pending)
#

setup() {
    load 'test_helper/common-setup.bash'
    _common_setup
}

teardown() {
    if [[ -n "$TEST_REPO_DIR" && -d "$TEST_REPO_DIR" ]]; then
        cleanup_test_repo "$TEST_REPO_DIR"
    fi
    _common_teardown
}

# Feature: Complete Workflow with MDT Integration

@test "workflow: creates worktree with project code from config" {
    # Given: repository with .mdt-config.toml containing code "WTA"
    # And: worktree.defaultPath is configured
    # When: running git wt 123
    # Then: should create worktree at configured path with name "WTA-123"

    TEST_REPO_DIR=$(mktemp -d)
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1

    # Setup config
    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    # Simulate the workflow
    worktree_input="123"
    ticket_number=$(echo "$worktree_input" | grep -Eo "[0-9][0-9][0-9]")

    # Get project code
    dot_config="$(git_test rev-parse --show-toplevel)/.mdt-config.toml"
    project_code=$(grep "^code = " "$dot_config" | cut -d"=" -f2 | tr -d " \"")

    # Construct worktree name
    if [[ "$worktree_input" =~ ^[0-9][0-9][0-9]$ ]]; then
        worktree="${project_code}-${ticket_number}"
    else
        worktree="$worktree_input"
    fi

    # Get path configuration
    default_path=$(git_test config worktree.defaultPath 2>/dev/null)
    project_dir="$(basename "$(git_test rev-parse --show-toplevel)")"

    # Resolve path
    default_path_with_project="$default_path"
    worktree_path=$(echo "$default_path_with_project" | sed "s/{worktree_name}/$worktree/g")
    repo_root="$(git_test rev-parse --show-toplevel)"
    worktree_path="$repo_root/$worktree_path"

    assert_equal "$worktree" "WTA-123"
    # Handle macOS /tmp -> /private/tmp symlink for the directory portion
    # The test creates temp directories with mktemp, which on macOS creates /private/tmp
    # But the script resolves to the symlinked /tmp
    repo_root=$(git_test rev-parse --show-toplevel)
    expected_worktree_path="$repo_root/.gitWT/WTA-123"
    assert_equal "$worktree_path" "$expected_worktree_path"
}

@test "workflow: creates worktree with custom project prefix" {
    # Given: input with custom project prefix "PROJ-456"
    # When: running git wt PROJ-456
    # Then: should create worktree with name "PROJ-456" (not add another prefix)

    TEST_REPO_DIR=$(mktemp -d)
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/{worktree_name}"

    worktree_input="PROJ-456"
    ticket_number=$(echo "$worktree_input" | grep -Eo "[0-9][0-9][0-9]")

    # Since input has prefix, should not add another
    if [[ "$worktree_input" =~ ^[0-9][0-9][0-9]$ ]]; then
        dot_config="$(git_test rev-parse --show-toplevel)/.mdt-config.toml"
        project_code=$(grep "^code = " "$dot_config" | cut -d"=" -f2 | tr -d " \"")
        if [ -n "$project_code" ]; then
            worktree="${project_code}-${ticket_number}"
        fi
    else
        worktree="$worktree_input"
    fi

    assert_equal "$worktree" "PROJ-456"
}

@test "workflow: creates worktree outside repository" {
    # Given: worktree.defaultPath with absolute path
    # When: running git wt
    # Then: should create worktree at absolute path outside repo

    TEST_REPO_DIR=$(mktemp -d)
    TEST_WORKTREE_BASE=$(mktemp -d)
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath "$TEST_WORKTREE_BASE/{worktree_name}"

    default_path=$(git_test config worktree.defaultPath 2>/dev/null)
    worktree="WTA-789"

    default_path_with_project="$default_path"
    worktree_path=$(echo "$default_path_with_project" | sed "s/{worktree_name}/$worktree/g")

    if [[ "$worktree_path" == /* ]]; then
        relative_flag="--no-relative-paths"
    else
        relative_flag="--relative-paths"
    fi

    assert_equal "$relative_flag" "--no-relative-paths"
    assert_equal "$worktree_path" "$TEST_WORKTREE_BASE/WTA-789"
}

@test "workflow: creates worktree with project_dir placeholder" {
    # Given: repo at /projects/my-app
    # And: worktree.defaultPath="../{project_dir}_{worktree_name}"
    # When: running git wt 101
    # Then: should create worktree at /projects/my-app_WTA-101

    TEST_REPO_DIR=$(mktemp -d)
    # Create with a specific name
    TEST_REPO_NAMED_DIR=$(mktemp -d -t "test-app-XXXXXX")
    TEST_REPO_DIR="$TEST_REPO_NAMED_DIR"
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath "../{project_dir}_{worktree_name}"

    default_path=$(git_test config worktree.defaultPath 2>/dev/null)
    worktree="WTA-101"
    project_dir="$(basename "$(git_test rev-parse --show-toplevel)")"

    # Replace placeholders
    if [[ "$default_path" == *"{project_dir}"* ]]; then
        default_path_with_project=$(echo "$default_path" | sed "s/{project_dir}/$project_dir/g")
    else
        default_path_with_project="$default_path"
    fi

    worktree_path=$(echo "$default_path_with_project" | sed "s/{worktree_name}/$worktree/g")

    # Convert relative to absolute
    if [[ "$worktree_path" == /* ]]; then
        :
    else
        repo_root="$(git_test rev-parse --show-toplevel)"
        worktree_path="$repo_root/$worktree_path"
    fi

    # Path should contain project_dir and worktree name
    assert_regex "$worktree_path" "$project_dir"
    assert_regex "$worktree_path" "WTA-101"
}

@test "workflow: interactive config setup when missing" {
    # Given: no worktree.defaultPath configured
    # When: running git wt
    # Then: should prompt to set default configuration

    TEST_REPO_DIR=$(mktemp -d)
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1

    git_test config --unset worktree.defaultPath 2>/dev/null || true
    git_test config --global --unset worktree.defaultPath 2>/dev/null || true

    # Check local config first, then global (fix for logical OR issue)
    default_path=$(git_test config worktree.defaultPath 2>/dev/null || echo "")
    if [[ -z "$default_path" ]]; then
        default_path=$(git_test config --global worktree.defaultPath 2>/dev/null || echo "")
    fi

    should_prompt=false
    if [ -z "$default_path" ]; then
        should_prompt=true
    fi

    assert "$should_prompt"
}

# Feature: Directory Creation

@test "creates: parent directories when they don't exist" {
    # Given: worktree path with non-existent parent directories
    # When: creating worktree
    # Then: should create parent directories first

    TEST_REPO_DIR=$(mktemp -d)
    create_test_repo "$TEST_REPO_DIR"
    cd "$TEST_REPO_DIR" || return 1

    create_mdt_config "$TEST_REPO_DIR" "WTA"
    git_test config worktree.defaultPath ".gitWT/deep/nested/path/{worktree_name}"

    default_path=$(git_test config worktree.defaultPath 2>/dev/null)
    worktree="WTA-111"

    default_path_with_project="$default_path"
    worktree_path=$(echo "$default_path_with_project" | sed "s/{worktree_name}/$worktree/g")
    repo_root="$(git_test rev-parse --show-toplevel)"
    worktree_path="$repo_root/$worktree_path"

    parent_dir=$(dirname "$worktree_path")

    # Simulate directory creation check
    would_create_dirs=true
    if [ ! -d "$parent_dir" ]; then
        would_create_dirs=true
    fi

    assert "$would_create_dirs"
    assert_regex "$parent_dir" "deep/nested/path"
}
